/*
 * Copyright Â© 2019 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* tslint:disable:max-file-line-count */

import {
    editModes,
    GitProject,
    HandlerContext,
    logger,
} from "@atomist/automation-client";
import {
    AutoMergeMethod,
    AutoMergeMode,
} from "@atomist/automation-client/lib/operations/edit/editModes";
import * as clj from "@atomist/clj-editors";
import {
    hasFile,
    predicatePushTest,
    PredicatePushTest,
    PushImpact,
    pushTest,
    PushTest,
    SdmGoalEvent,
    spawnLog,
    TransformPresentation,
} from "@atomist/sdm";
import {
    ProjectVersioner,
    readSdmVersion,
} from "@atomist/sdm-core";
import {
    DockerImageNameCreator,
    DockerOptions,
} from "@atomist/sdm-pack-docker";
import { ApplyTargetParameters } from "@atomist/sdm-pack-fingerprint/lib/handlers/commands/applyFingerprint";
import * as df from "dateformat";
import * as _ from "lodash";
import * as path from "path";

export const NodeProjectVersioner: ProjectVersioner = async (sdmGoal, p, log) => {
    const pjFile = await p.getFile("package.json");
    const pj = JSON.parse(await pjFile.getContent());
    const branch = sdmGoal.branch.split("/").join(".");

    let branchSuffix = "";
    if (branch !== "master") {
        branchSuffix = "master.";
    }

    const newVersion = `${pj.version}-${branchSuffix}${df(new Date(), "yyyymmddHHMMss")}`;

    await spawnLog(
        "npm",
        ["--no-git-tag-version", "version", newVersion],
        {
            log,
        },
    );

    return newVersion;
};

export const HasAtomistFile: PredicatePushTest = predicatePushTest(
    "Has Atomist file",
    hasFile("atomist.sh").predicate);

export const HasAtomistDockerfile: PredicatePushTest = predicatePushTest(
    "Has Atomist Dockerfile file",
    hasFile("docker/Dockerfile").predicate);

export const HasIntegrationTestMarkerFile: PredicatePushTest = predicatePushTest(
    "Has marker file to run integration tests",
    hasFile("requires-integration-test").predicate);

export const HasNeoApolloDockerfile: PredicatePushTest = predicatePushTest(
    "Has an apollo Dockerfile file",
    hasFile("apollo/Dockerfile").predicate);

export const FingerprintGoal = new PushImpact();

const AtomistWorkspaces = "T095SFFBK,AK748NQC5";
const WorkspacesFilename = "workspaces";

export const IsWorkspaceWhitelisted: PushTest =
    pushTest(`project has workspaces file that contains the current workspace id`,
        async pci => {
            const file = await pci.project.getFile(WorkspacesFilename);
            // we pretend that all projects by default have a file white-listing AtomistHQ
            let fileContent = AtomistWorkspaces;
            if (file) {
                fileContent = await file.getContent();
            }
            return fileContent.includes(pci.context.workspaceId);
        },
    );

export const AutoApproveEditModeMaker: TransformPresentation<ApplyTargetParameters> = (ci, p) => {
    // name the branch apply-target-fingerprint with a Date
    // title can be derived from ApplyTargetParameters
    // body can be derived from ApplyTargetParameters
    // optional message is undefined here
    // target branch is hard-coded to master
    return new editModes.PullRequest(
        `apply-target-fingerprint-${Date.now()}`,
        `${ci.parameters.title}`,
        `> generated by Atomist \`\`\`${ci.parameters.body}\`\`\``,
        undefined,
        ci.parameters.branch || "master",
        {
            method: AutoMergeMethod.Squash,
            mode: AutoMergeMode.SuccessfulCheck,
        });
};

export const apolloImageNamer: DockerImageNameCreator =
    async (
        p: GitProject,
        sdmGoal: SdmGoalEvent,
        options: DockerOptions,
        ctx: HandlerContext) => {

        const projectclj = path.join(p.baseDir, "project.clj");
        const newversion = await readSdmVersion(
            sdmGoal.repo.owner,
            sdmGoal.repo.name,
            sdmGoal.repo.providerId,
            sdmGoal.sha,
            sdmGoal.branch,
            ctx);
        const projectName = _.last(clj.getName(projectclj).split("/"));

        logger.info(`Docker Image name is generated from ${projectclj} name and version ${projectName} ${newversion}`);

        return [{
            name: `${projectName}-apollo`,
            registry: Array.isArray(options.registry) ? options.registry[0].registry : options.registry.registry,
            tags: [newversion],
        }];
    };
